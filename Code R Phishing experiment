---
title: "Recherche"
author: "Beaufils - Cochet - Dyèvre"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
      number_sections: yes
    theme: readable
    df_print: paged
    code_folding: hide
  html_notebook:
    toc: yes
---

<style>
body {
text-align: justify}
</style>

# Introduction 

In March 2018, the film company Pathé was the victim of a phishing attack, causing an estimated loss of more than 19 million euros. In addition to significant financial damage, phishing poses a significant risk to the protection of personal data. It is therefore now necessary to prevent this type of attack.

Phishing consists of obtaining personal data by gaining the user's trust, in particular by pretending to be an official institution. For an employee, it is for example an e-mail pretending to be the IT department of his company. The employee is then asked to enter his or her passwords in order to solve a fake IT problem. 

Faced with these risks, prevention campaigns are becoming more and more numerous and 95% of companies claim to be conducting them. Nevertheless, it is difficult to know if these techniques are effective and which ones are the most efficient. 

To answer these questions, Aurelien Baillon, Jeroen de Bruin, Aysil Emirmahmutoglu, Evelien van de Veer and Bram van Dijk from Erasmus University Rotterdam conducted an experiment at the Dutch Ministry of Economic Affairs and Climate Policy.

The experiment was carried out on 10929 employees of the Ministry, without them being informed that they were participating in an experiment. The employees were divided according to the 184 core units of the Ministry. Each cluster was randomly assigned to one of four groups: Control, Exp, Info and ExpInfo. The experiment was divided into five periods (T in {1, . . . , 5}). At T = 2, T = 3, T = 4, the Info units received phishing prevention emails. At T = 1, the Exp units received a fake phishing email and a short debrief. The ExpInfo units received both types of treatment. At T = 5, all groups received a phishing email. 
It was apparently not possible to ensure that the treatment units actually received and read their e-mails, which forms an obvious bias in the results of the experiment. In addition, a whole division of the ministry was unintentionally notified that the first phishing email was fake. Thus, The Control and Info units of division C received this notification as well. This may have affected the results, creating intervention spillover effects within that division. Therefore, we will comment on the results with and without this division, which will also allow us to test the robustness of the treatments. 




# Presentation of data and variables

The file “phishing_dataset.csv” gives the data obtained in the experiment. 

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing <- read.csv("/Users/f-x/Downloads/phishing_dataset.csv") # data loading
head(data_phishing)
```

- Column “group” indicates in which treatment a subject was with “1”, “2”, “3” and “4” corresponding to “Control”, “Info”, “Exp” and “ExpInfo”, respectively. 

- Columns “cluster” and “division” indicate at which basic unit and organizational division a subject is working. Indeed, the authors randomized the subjects at the level of the lowest known organizational unit, henceforth referred to as “basic unit”. In total there is 184 unique basic units, with an average of 61 subjects per basic unit. The authors have not opted for randomization at the individual level “to avoid contamination of the results by intervention spillover effects”. 

- Column “age” indicates the age of the subject. 

- Column “gender” indicates that a subject is female if the value is “F” and a male if the value is “M”. 

- Column “int_employee” is a dummy variable indicating whether a subject is an internal employee. 

- Columns “visit”, “fill” and “visit_fill” are response variables to the second phishing email at time T= 5. “visit” indicates whether subjects clicked the link and visited the website, “fill” indicates whether subjects filled in their password, and “visit_fill” indicates whether they filled in their password conditional on having visited the website. 

- Similarly, columns “visit_1”, “fill_1” and “visit_fill_1” are response variables to the first phishing email at time T=1 (only groups Exp and ExpInfo received this email.). 


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
library(tidyverse)
library(cowplot)
library(gtsummary)
library(knitr)
library(kableExtra)
```
# Data cleaning

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing <- data_phishing %>%
  # recoding of the treatment variable
  mutate(group = case_when(
    group == 1 ~ "Control",
    group == 2 ~ "Info",
    group == 3 ~ "Exp",
    group == 4 ~ "ExpInfo"
  )) %>%
  
  mutate(group = fct_relevel(group, "Control", "Info", "Exp", "ExpInfo")) %>%
  # recoding of the age variable
  mutate(
    age_categories = case_when(
      age <= 25 ~ "16-25",
      age >= 26 & age <= 35 ~ "26-35",
      age >= 36 & age <= 45 ~ "36-45",
      age >= 46 & age <= 55 ~ "46-55",
      age > 55 ~ ">55"
    )
  ) %>%
  mutate(age_categories = fct_relevel(age_categories, "16-25", "26-35", "36-45", "46-55")) %>%
  # recoding of the gender variable 
  mutate(gender = case_when(gender == "M" ~ 1,
                            gender == "F" ~ 0)) %>%
  # change order variable division with B as reference
  mutate(division = fct_relevel(division, "B", "A", "C", "D", "E")) 

data_phis_c <- data_phishing %>%
  filter(division == 'A' | division == 'B' | division == 'D' | division == 'E') #creation of a data table without the C division

Outcome = c('Visit', 'Fill', 'Visit_Fill')
Group = c('Control','Info','Exp','ExpInf')
```

Unit characteristics and similarity tests

- Total number of units per group

"We implemented two interventions: information provision (Info) and experience (Exp).
We used a 2x2 design and subjects were divided into four groups of roughly equal size: Control
(2723 employees), Info (2740), Exp (2724) and ExpInfo (2742)."

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing %>%
  group_by(group) %>%
  summarise(nb_group = n()) #count of units by group
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c %>%
  group_by(group) %>%
  summarise(nb_group = n())
```

- Number of female and male units

"Most subjects were males (60,6%), [...]."

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing %>%
  group_by(gender) %>% 
  summarise(nb_obs = n()) #count of units by gender
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c %>%
  group_by(gender) %>%
  summarise(nb_obs = n())
```
```{r, eval = TRUE, message = FALSE, warning =  FALSE}

rep_sex = mean(data_phishing$gender, na.rm = TRUE)*100 # gender distribution among the units
rep_sex_c = mean(data_phis_c$gender, na.rm = TRUE)*100 

rep_sex
rep_sex_c
```

- Age of the units

* Overall average

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
moy_age = mean(data_phishing$age, na.rm = TRUE) # age distribution among the units
moy_age_c = mean(data_phis_c$age, na.rm = TRUE)

moy_age
moy_age_c
```

* Age of the units according to the treatment

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phishing) + # boxplot showing the age distribution according to the treatement
  geom_boxplot(aes(x = as.character(group), y = age , color = as.character(group)))
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phishing) + # plot showing the age distribution according to the treatement
  geom_density(aes(x = age, color = group))
```


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phis_c) +
  geom_boxplot(aes(x = as.character(group), y = age , color = as.character(group)))
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phis_c) +
  geom_density(aes(x = age, color = group)) 
```

- Summary table of the characteristics of the units depending on the treatment


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing %>%
  group_by(group) %>% # data are grouped by treatment
  summarise(nb_obs = n(), mean_age = mean(age, na.rm = TRUE), sex_repartition = mean(gender, na.rm = TRUE)*100, mean_int_employee = mean(int_employee, na.rm = TRUE)*100,) # mean of the different characteristics of the units
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c %>%
  group_by(group) %>%
  summarise(nb_obs = n(), mean_age = mean(age, na.rm = TRUE), sex_repartition = mean(gender, na.rm = TRUE)*100, mean_int_employee = mean(int_employee, na.rm = TRUE)*100,)
```
Before the removal of division C due to an error on the part of the researchers, the different treatment groups had roughly the same characteristics. The removal of this division caused slight shifts in the distribution of the control variables in the treatment groups. These groups are no longer completely identical or of the same size. For example, there is a difference of about 400 units between the control group and the "Info" treatment group.

# Randomization inference


We decided to focus our randomization inference by removing the C division from the analysis. Indeed, given the difficulties encountered by the researchers with this unit, it seemed to us biased to take it into account in this analysis.

We have divided this analysis by looking at each treatment individually. In this way, we can first determine which of the treatments definitely reduce the likelihood of falling victim to a phishing attack.


I. Calculation of ATEs for each treatment

A. Exp

```{r, eval = TRUE, message = FALSE, warning =  FALSE}


observed_difference_v = mean(data_phis_c$visit[data_phis_c$group == 'Exp']) - mean(data_phis_c$visit[data_phis_c$group == 'Control']) # difference of the averages for each treatment (for the Exp group)
observed_difference_f = mean(data_phis_c$fill[data_phis_c$group == 'Exp']) - mean(data_phis_c$fill[data_phis_c$group == 'Control']) 
observed_difference_vf = mean(data_phis_c$visit_fill[data_phis_c$group == 'Exp'], na.rm = TRUE) - mean(data_phis_c$visit_fill[data_phis_c$group == 'Control'], na.rm = TRUE) 


print(data.frame(Outcome = c('Visit', 'Fill', 'Visit_Fill'), ATE = c(observed_difference_v,observed_difference_f, observed_difference_vf)))  # displaying differences
```

The observed differences seem to establish a negative correlation between the 'Exp' treatment and the control group: this treatment reduced the different outcomes by 11 to 13 percentage points. For instance, the number of units which visited the website has been reduced by 13 percentage points, compared to the control group.  Let's see if this difference stands up to randomisation inference.


B. Info

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
observed_difference_v_info = mean(data_phis_c$visit[data_phis_c$group == 'Info']) - mean(data_phis_c$visit[data_phis_c$group == 'Control']) # difference of the averages for each treatment (for the Info group)
observed_difference_f_info = mean(data_phis_c$fill[data_phis_c$group == 'Info']) - mean(data_phis_c$fill[data_phis_c$group == 'Control'])
print(observed_difference_f_info)
observed_difference_vf_info = mean(data_phis_c$visit_fill[data_phis_c$group == 'Info'], na.rm = TRUE) - mean(data_phis_c$visit_fill[data_phis_c$group == 'Control'], na.rm = TRUE) 

  
print(data.frame(Outcome = c('Visit', 'Fill', 'Visit_Fill'), ATE = c(observed_difference_v_info,observed_difference_f_info, observed_difference_vf_info)))  # displaying differences
```

The observed differences seem to establish a negative correlation between the 'Info' treatment and the control group: this treatment reduced the different outcomes by 11 to 13 percentage points. For instance, the number of units which visited the website has been reduced by 8 percentage points, compared to the control group.  Let's see if this difference stands up to randomisation inference.


C. ExpInfo

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

observed_difference_v_expinfo = mean(data_phis_c$visit[data_phis_c$group == 'ExpInfo']) - mean(data_phis_c$visit[data_phis_c$group == 'Control']) # difference of the averages for each treatment (for the ExpInfo group)
observed_difference_f_expinfo = mean(data_phis_c$fill[data_phis_c$group == 'ExpInfo']) - mean(data_phis_c$fill[data_phis_c$group == 'Control']) 
print(observed_difference_f_expinfo)
observed_difference_vf_expinfo = mean(data_phis_c$visit_fill[data_phis_c$group == 'ExpInfo'], na.rm = TRUE) - mean(data_phis_c$visit_fill[data_phis_c$group == 'Control'], na.rm = TRUE) 
print(observed_difference_vf_expinfo)

print(data.frame(Outcome = c('Visit', 'Fill', 'Visit_Fill'), ATE = c(observed_difference_v_expinfo,observed_difference_f_expinfo, observed_difference_vf_expinfo))) # displaying differences

```

The observed differences seem to establish a negative correlation between the 'ExpInfo' treatment and the control group: this treatment reduced the different outcomes by 9 to 15 percentage points. For instance, the number of units which visited the website has been reduced by 10 percentage points, compared to the control group.  Let's see if this difference stands up to randomisation inference.


II. Calculation of the proportions of treated units

Here we calculate the proportions of treated units for each treatment compared to the numbers of control units. These proportions are necessary for randomization inference in a cluster experiment like ours.

A. Exp

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c_exp <- data_phis_c %>%
  filter(group == 'Control' | group == 'Exp') %>%
  mutate(ind_group = ifelse(group == 'Exp',1,0)) # creation of an indicator worth 1 if the unit is treated and 0 otherwise
                              

prop_exp = sum(data_phis_c_exp$ind_group)/nrow(data_phis_c_exp) # proportion of units receiving the Exp treatment
```

B. Info

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c_info <- data_phis_c %>%
  filter(group == 'Control' | group == 'Info') %>%
  mutate(ind_group = ifelse(group == 'Info',1,0)) # creation of an indicator worth 1 if the unit is treated and 0 otherwise
                            

prop_info = sum(data_phis_c_info$ind_group)/nrow(data_phis_c_info) # proportion of units receiving the Info treatment
```

C. ExpInfo

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c_expinfo <- data_phis_c %>%
  filter(group == 'Control' | group == 'ExpInfo') %>%
  mutate(ind_group = ifelse(group == 'ExpInfo',1,0)) # creation of an indicator worth 1 if the unit is treated and 0 otherwise
                            

prop_expinfo = sum(data_phis_c_expinfo$ind_group)/nrow(data_phis_c_expinfo) # proportion of units receiving the ExpInfo treatment
```


III. Randomization inference loop


As explained, our experiment is based on cluster allocation. Thus, it is necessary to randomise on the clusters and not on the units themselves. As each cluster consists of one and the same treatment, we randomised according to the proportion of treated to control group. 

A. Exp


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
diff_simulations <- rep(NA, 1000)
diff_simulations_f_exp <- rep(NA, 1000)
diff_simulations_vf_exp <- rep(NA, 1000)


#loop for simulations
for (i in 1:1000){

data_phis_c_exp <- data_phis_c_exp %>%
#We construct a new treat variable (with mutate function) which randomly mixes (sample function) the elements of the treat variable  
  group_by(cluster) %>%
  mutate(new_group = rbinom(1, 1, prop_exp)) %>%
  mutate(new_group = case_when(new_group == 1 ~ 'Exp',
                               new_group == 0 ~ 'Control'))

#We calculate the differences for each of the 1000 distributions that I place at the i-th coordinate
diff_simulations[i] <- mean(data_phis_c_exp$visit[data_phis_c_exp$new_group == "Exp"]) - mean(data_phis_c_exp$visit[data_phis_c_exp$new_group=="Control"])

diff_simulations_f_exp[i] <- mean(data_phis_c_exp$fill[data_phis_c_exp$new_group == "Exp"]) - mean(data_phis_c_exp$fill[data_phis_c_exp$new_group=="Control"])

diff_simulations_vf_exp[i] <- mean(data_phis_c_exp$visit_fill[data_phis_c_exp$new_group == "Exp"], na.rm = TRUE) - mean(data_phis_c_exp$visit_fill[data_phis_c_exp$new_group=="Control"], na.rm = TRUE)
}

```



```{r, eval = TRUE}

data_simulations <- tibble(diff_simulations=diff_simulations)
graph_exp <- ggplot(data_simulations, aes(x = diff_simulations)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  #The average of the random differences in black
  geom_vline(xintercept = mean(data_simulations$diff_simulations), color = 'black') +
  #The actual average observed in coral
  geom_vline(xintercept = observed_difference_v, color = 'coral') +
  xlab("Visit") +
  theme_minimal()

data_simulations_f_exp <- tibble(diff_simulations_f_exp=diff_simulations_f_exp)
graph_fill_exp <- ggplot(data_simulations_f_exp, aes(x = diff_simulations_f_exp)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_f_exp$diff_simulations_f_exp), color = 'black') +
  geom_vline(xintercept = observed_difference_f, color = 'coral') +
  xlab("Fill") +
  theme_minimal()

data_simulations_vf_exp <- tibble(diff_simulations_vf_exp=diff_simulations_vf_exp)
graph_visitfill_exp <- ggplot(data_simulations_vf_exp, aes(x = diff_simulations_vf_exp)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_vf_exp$diff_simulations_vf_exp), color = 'black') +
  geom_vline(xintercept = observed_difference_vf, color = 'coral') +
  xlab("Visit_Fill") +
  theme_minimal()


print(plot_grid(graph_exp,graph_fill_exp,graph_visitfill_exp))
```

P-values

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Calculation of the one-sided and the two-sided p-value

opve = (sum(data_simulations$diff_simulations <= observed_difference_v)/1000)*100 # outcome Visit
tpve = (sum(abs(data_simulations$diff_simulations) >=  abs(observed_difference_v))/1000)*100

opfe = (sum(data_simulations_f_exp$diff_simulations_f_exp <= observed_difference_f)/1000)*100 # outcome Fill
tpfe = (sum(abs(data_simulations_f_exp$diff_simulations_f_exp) >=  abs(observed_difference_f))/1000)*100

opvfe = (sum(data_simulations_vf_exp$diff_simulations_vf_exp <= observed_difference_vf)/1000)*100 # outcome VisitFill
tpvfe = (sum(abs(data_simulations_vf_exp$diff_simulations_vf_exp) >=  abs(observed_difference_vf))/1000)*100

data.frame(outcome = c('Visit','Fill','Visit_Fill'), one_sided_p_values = c(opve, opfe, opvfe), two_sided_p_values = c(tpve ,tpfe ,tpvfe))

```
As the p-values are relatively low, it seems consistent to reject the sharp null hypothesis for this treatment.


B. Info


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
diff_simulations_info <- rep(NA, 1000)
diff_simulations_f_info <- rep(NA, 1000)
diff_simulations_vf_info <- rep(NA, 1000)
for (i in 1:1000){

data_phis_c_info <- data_phis_c_info %>%
  group_by(cluster) %>%
  mutate(new_group = rbinom(1, 1, prop_info)) %>%
  mutate(new_group = case_when(new_group == 1 ~ 'Info',
                               new_group == 0 ~ 'Control'))

diff_simulations_info[i] <- mean(data_phis_c_info$visit[data_phis_c_info$new_group == "Info"]) - mean(data_phis_c_info$visit[data_phis_c_info$new_group=="Control"])

diff_simulations_f_info[i] <- mean(data_phis_c_info$fill[data_phis_c_info$new_group == "Info"]) - mean(data_phis_c_info$fill[data_phis_c_info$new_group=="Control"])

diff_simulations_vf_info[i] <- mean(data_phis_c_info$visit_fill[data_phis_c_info$new_group == "Info"], na.rm = TRUE) - mean(data_phis_c_info$visit_fill[data_phis_c_info$new_group=="Control"], na.rm = TRUE)
}

```

```{r, eval = TRUE}
data_simulations_info <- tibble(diff_simulations_info=diff_simulations_info)
graph_info <- ggplot(data_simulations_info, aes(x = diff_simulations_info)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_info$diff_simulations_info), color = 'black') +
  geom_vline(xintercept = observed_difference_v_info, color = 'coral') +
  xlab("Visit") +
  theme_minimal()

data_simulations_f_info <- tibble(diff_simulations_f_info=diff_simulations_f_info)
graph_fill_info <- ggplot(data_simulations_f_info, aes(x = diff_simulations_f_info)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_f_info$diff_simulations_f_info), color = 'black') +
  geom_vline(xintercept = observed_difference_f_info, color = 'coral') +
  xlab("Fill") +
  theme_minimal()

data_simulations_vf_info <- tibble(diff_simulations_vf_info=diff_simulations_vf_info)
graph_visitfill_info <- ggplot(data_simulations_vf_info, aes(x = diff_simulations_vf_info)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_vf_info$diff_simulations_vf_info), color = 'black') +
  geom_vline(xintercept = observed_difference_vf_info, color = 'coral') +
  xlab("Visit_Fill") +
  theme_minimal()

plot_grid(graph_info,graph_fill_info,graph_visitfill_info)
```

P-values

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Calculation of the one-sided and the two-sided p-value

opvi = (sum(data_simulations_info$diff_simulations_info <= observed_difference_v_info)/1000)*100 # outcome Visit
tpvi = (sum(abs(data_simulations_info$diff_simulations_info) >=  abs(observed_difference_v_info))/1000)*100

opfi = (sum(data_simulations_f_info$diff_simulations_f_info <= observed_difference_f_info)/1000)*100 # outcome Fill
tpfi = (sum(abs(data_simulations_f_info$diff_simulations_f_info) >=  abs(observed_difference_f_info))/1000)*100

opvfi = (sum(data_simulations_vf_info$diff_simulations_vf_info <= observed_difference_vf_info)/1000)*100 # outcome VisitFill
tpvfi = (sum(abs(data_simulations_vf_info$diff_simulations_vf_info) >=  abs(observed_difference_vf_info))/1000)*100

data.frame(Outcome, one_sided_p_values = c(opvi, opfi, opvfi), two_sided_p_values = c(tpvi ,tpfi ,tpvfi))

```

As we see from the graph and table above, it is more difficult here to reject the sharp null hypothesis for this treatment and particularly for the 'Visit' outcome. Indeed, about 10% of the values are more extreme than that observed for this outcome. Nevertheless, the general trend seems to be in the direction of the effectiveness of the treatment.


C. ExpInfo

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
diff_simulations_expinfo <- rep(NA, 1000)
diff_simulations_f_expinfo <- rep(NA, 1000)
diff_simulations_vf_expinfo <- rep(NA, 1000)

for (i in 1:1000){

data_phis_c_expinfo <- data_phis_c_expinfo %>%
  group_by(cluster) %>%
  mutate(new_group = rbinom(1,1,prop_expinfo)) %>%
  mutate(new_group = case_when(new_group == 1 ~ 'ExpInfo',
                               new_group == 0 ~ 'Control'))

diff_simulations_expinfo[i] <- mean(data_phis_c_expinfo$visit[data_phis_c_expinfo$new_group == "ExpInfo"]) - mean(data_phis_c_expinfo$visit[data_phis_c_expinfo$new_group=="Control"])

diff_simulations_f_expinfo[i] <- mean(data_phis_c_expinfo$fill[data_phis_c_expinfo$new_group == "ExpInfo"]) - mean(data_phis_c_expinfo$fill[data_phis_c_expinfo$new_group=="Control"])

diff_simulations_vf_expinfo[i] <- mean(data_phis_c_expinfo$visit_fill[data_phis_c_expinfo$new_group == "ExpInfo"], na.rm = TRUE) - mean(data_phis_c_expinfo$visit_fill[data_phis_c_expinfo$new_group=="Control"], na.rm = TRUE)
}
```


```{r, eval = TRUE}

data_simulations_expinfo <- tibble(diff_simulations_expinfo=diff_simulations_expinfo)
graph_expinfo <- ggplot(data_simulations_expinfo, aes(x = diff_simulations_expinfo)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_expinfo$diff_simulations_expinfo), color = 'black') +
  geom_vline(xintercept = observed_difference_v_expinfo, color = 'coral') +
  xlab("Visit") + 
  theme_minimal()

data_simulations_f_expinfo <- tibble(diff_simulations_f_expinfo=diff_simulations_f_expinfo)
graph_fill_expinfo <- ggplot(data_simulations_f_expinfo, aes(x = diff_simulations_f_expinfo)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_f_expinfo$diff_simulations_f_expinfo), color = 'black') +
  geom_vline(xintercept = observed_difference_f_expinfo, color = 'coral') +
  xlab("Fill") +
  theme_minimal()

data_simulations_vf_expinfo <- tibble(diff_simulations_vf_expinfo=diff_simulations_vf_expinfo)
graph_visitfill_expinfo <- ggplot(data_simulations_vf_expinfo, aes(x = diff_simulations_vf_expinfo)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_vf_expinfo$diff_simulations_vf_expinfo), color = 'black') +
  geom_vline(xintercept = observed_difference_vf_expinfo, color = 'coral') +
  xlab("Visit_Fill") +
  theme_minimal()


plot_grid(graph_expinfo,graph_fill_expinfo,graph_visitfill_expinfo)
```

P-values 

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
#Calcul de la one-sided et two-sided p-value

opvei = (sum(data_simulations_expinfo$diff_simulations_expinfo <= observed_difference_v_expinfo)/1000)*100 # outcome Visit
tpvei = (sum(abs(data_simulations_expinfo$diff_simulations_expinfo) >=  abs(observed_difference_v_expinfo))/1000)*100

opfei = (sum(data_simulations_f_expinfo$diff_simulations_f_expinfo <= observed_difference_f_expinfo)/1000)*100 # outcome Fill
tpfei = (sum(abs(data_simulations_f_expinfo$diff_simulations_f_expinfo) >=  abs(observed_difference_f_expinfo))/1000)*100

opvfei = (sum(data_simulations_vf_expinfo$diff_simulations_vf_expinfo <= observed_difference_vf_expinfo)/1000)*100 # outcome VisitFill
tpvfei = (sum(abs(data_simulations_vf_expinfo$diff_simulations_vf_expinfo) >=  abs(observed_difference_vf_expinfo))/1000)*100

data.frame(Outcome, one_sided_p_values = c(opvei, opfei, opvfei), two_sided_p_values = c(tpvei ,tpfei, tpvfei))
```

As the p-values are relatively low, it seems consistent to reject the sharp null hypothesis for this treatment.



IV. Final results

```{r, echo = TRUE, message = FALSE, warning = FALSE, fig.width = 10, fig.height = 5, fig.fullwidth=TRUE}
first_row <- plot_grid(graph_exp, graph_fill_exp, graph_visitfill_exp, labels = 'Exp', ncol = 3)
second_row <- plot_grid(graph_info, graph_fill_info, graph_visitfill_info, labels = 'Info', ncol = 3)
third_row <- plot_grid(graph_expinfo, graph_fill_expinfo, graph_visitfill_expinfo, labels = 'ExpInfo', ncol = 3)

plot_grid(first_row, second_row, third_row,  nrow = 3) # displaying final results
```



Weighted t-test


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
#creation of tables containing the proportions of outcomes per cluster
data_wtt <- data_phishing %>%
  group_by(group, cluster) %>%
  summarise(prop_cluster = n()/10929, prop_fill = sum(fill)/n(), prop_visit = sum(visit)/n(),  prop_visit_fill = sum(visit_fill, na.rm = TRUE)/sum(visit))

data_wtt_c <- data_phis_c %>%
  group_by(group, cluster) %>%
  summarise(prop_cluster = n()/10929, prop_fill = sum(fill)/n(), prop_visit = sum(visit)/n(),  prop_visit_fill = sum(visit_fill, na.rm = TRUE)/sum(visit))


```

Control Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

fc = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'Control'], w = data_wtt$prop_cluster[data_wtt$group == 'Control']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the Control group

vc = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'Control'], w = data_wtt$prop_cluster[data_wtt$group == 'Control']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the Control group

vfc = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'Control'], w = data_wtt$prop_cluster[data_wtt$group == 'Control'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the Control group


# Without division C

fc_c = weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'Control'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Control'])

vc_c = weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'Control'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Control'])

vfc_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'Control'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Control'], na.rm = TRUE)

```

Info Group
```{r, eval = TRUE, message = FALSE, warning =  FALSE}

vi = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'Info'], w = data_wtt$prop_cluster[data_wtt$group == 'Info']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the Info group

fi = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'Info'], w = data_wtt$prop_cluster[data_wtt$group == 'Info']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the Info group

vfi = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'Info'], w = data_wtt$prop_cluster[data_wtt$group == 'Info'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the Info group
  
# Without division C

vi_c= weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'Info'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Info'])

fi_c =weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'Info'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Info'])

vfi_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'Info'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Info'], na.rm = TRUE)
  
```

Exp Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

ve = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'Exp'], w = data_wtt$prop_cluster[data_wtt$group == 'Exp']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the Exp group

fe = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'Exp'], w = data_wtt$prop_cluster[data_wtt$group == 'Exp']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the Exp group

vfe = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'Exp'], w = data_wtt$prop_cluster[data_wtt$group == 'Exp'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the Exp group
  
# Without division C

ve_c = weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'Exp'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Exp'])

fe_c = weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'Exp'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Exp'])

vfe_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'Exp'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Exp'], na.rm = TRUE)
```

ExpInfo Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

vei = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'ExpInfo'], w = data_wtt$prop_cluster[data_wtt$group == 'ExpInfo']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the ExpInfo group

fei = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'ExpInfo'], w = data_wtt$prop_cluster[data_wtt$group == 'ExpInfo']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the ExpInfo group

vfei = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'ExpInfo'], w = data_wtt$prop_cluster[data_wtt$group == 'ExpInfo'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the ExpInfo group

# Without division C

vei_c = weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'ExpInfo'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'ExpInfo'])

fei_c = weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'ExpInfo'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'ExpInfo'])

vfei_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'ExpInfo'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'ExpInfo'], na.rm = TRUE)



```
  
```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 

dataggv <- data.frame(group = c('Control',"Info","Exp","ExpInfo"), visit_moyenne = c(vc,vi,ve,vei)*100 ,visit_moyenne_c = c(vc_c,vi_c,ve_c,vei_c)*100) # creation of data tables to allow plotting results

dataggf <- data.frame(group = c('Control',"Info","Exp","ExpInfo"), fill_moyenne = c(fc,fi,fe,fei)*100 ,fill_moyenne_c = c(fc_c,fi_c,fe_c,fei_c)*100)

dataggvf <- data.frame(group = c('Control',"Info","Exp","ExpInfo"), vf_moyenne = c(vfc,vfi,vfe,vfei)*100 ,vf_moyenne_c = c(vfc_c,vfi_c,vfe_c,vfei_c)*100)


ggv = ggplot(dataggv, aes(x = group, y = visit_moyenne_c)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = visit_moyenne_c), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,40) +
ggtitle("Proportion of Visits by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()


ggf = ggplot(dataggf, aes(x = group, y = fill_moyenne_c)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = fill_moyenne_c), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,40) +
ggtitle("Proportion of Fill by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()


ggvf = ggplot(dataggvf, aes(x = group, y = vf_moyenne_c)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = vf_moyenne_c), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,80) +
ggtitle("Proportion of Visit_Fill by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()


plot_grid(ggv, ggf, ggvf) # displaying of the 3 plots together

```



# Linear regression analysis

# With division C

1. Nesting data by outcome

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# nesting data by outcome
data_regression <- data_phishing %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression #displaying the data frame
```

2. Creating of a function to do a regression :

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# we do a regression
function_regression <- function(data){
  data %>%
  lm(value ~ group + gender + as.factor(int_employee) + age_categories + division, data = .) %>%
  broom::tidy(., conf.int = TRUE) %>%
  filter(term %in% c("groupExp", "groupExpInfo", "groupInfo")) %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(-term), ~ round(.*100, 1))
}
```

3. The function is applied using the command `map()` :

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# application of the function
data_regression <- data_regression %>%
  mutate(regression_output = map(data, ~ function_regression(.)))

data_regression
```

4. The results must now be displayed. We need to "unnest" the data table:

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# unnesting the result
data_regression <- data_regression %>%
  select(-data) %>%
  unnest(regression_output)

# displaying of the table
data_regression
```

5. The 95% confidence intervals can be plotted:

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
# make the graph
data_regression %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```
# Without division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# nesting data by outcome
data_regression_c <- data_phis_c %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression_c #displaying the data frame
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# application of the function
data_regression_c <- data_regression_c %>%
  mutate(regression_output = map(data, ~ function_regression(.)))

data_regression_c
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# unnesting the result
data_regression_c <- data_regression_c %>%
  select(-data) %>%
  unnest(regression_output)

# displaying of the table
data_regression_c
```

5. The 95% confidence intervals can be plotted:

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
# make the graph
data_regression_c %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```

# Robustness of the results

We now test the robustness of the results, for which we reproduce the same regressions as before but without the control variables.

# With the division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2 <- data_phishing %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression2
```

2. Creating of a second function to do a regression (without the control variables):

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
function_regression2 <- function(data){
  data %>%
  lm(value ~ group, data = .) %>%
  broom::tidy(., conf.int = TRUE) %>%
  filter(term %in% c("groupExp", "groupExpInfo", "groupInfo")) %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(-term), ~ round(.*100, 1))
}
```

3. The function is applied using the command `map()` :

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2 <- data_regression2 %>%
  mutate(regression_output = map(data, ~ function_regression2(.)))

data_regression2
```

The results must now be displayed. We need to "unnest" the data table:

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2 <- data_regression2 %>%
  select(-data) %>%
  unnest(regression_output)

data_regression2
```

5. The 95% confidence intervals can be plotted:

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
data_regression2 %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```

# Without the division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2_c <- data_phis_c %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression2_c
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2_c <- data_regression2_c %>%
  mutate(regression_output = map(data, ~ function_regression2(.)))

data_regression2_c
```

The results must now be displayed. We need to "unnest" the data table:

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2_c <- data_regression2_c %>%
  select(-data) %>%
  unnest(regression_output)

data_regression2_c
```

5. The 95% confidence intervals can be plotted:

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
data_regression2_c %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```
