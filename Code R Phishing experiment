---
title: "Reproduction of a randomized experiment - Informing, simulating experience, or both: A field experiment on phishing risks"
author: "Martin Beaufils - Julien Cochet - François-Xavier Dyèvre"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
      number_sections: yes
    theme: readable
    df_print: paged
    code_folding: hide
  html_notebook:
    toc: yes
---

<style>
body {
text-align: justify}
</style>


## Introduction 

In March 2018, the film company Pathé was the victim of a phishing attack, causing an estimated loss of more than 19 million euros. In addition to significant financial damage, phishing poses a significant risk to the protection of personal data. It is therefore now necessary to prevent this type of attack.

Phishing consists of obtaining personal data by gaining the user's trust, in particular by pretending to be an official institution. For an employee, it is for example an e-mail pretending to be the IT department of his company. The employee is then asked to enter his or her passwords in order to solve a fake IT problem. 

Faced with these risks, prevention campaigns are increasingly numerous and a majority of companies claim to conduct them internally. Nevertheless, it is difficult to know if these techniques are effective and which ones are the most efficient. 

To answer these questions, Aurelien Baillon, Jeroen de Bruin, Aysil Emirmahmutoglu, Evelien van de Veer and Bram van Dijk from Erasmus University Rotterdam conducted an experiment at the Dutch Ministry of Economic Affairs and Climate Policy.

The experiment was carried out on 10929 employees of the Ministry, without them being informed that they were participating in an experiment. The employees were divided according to the 184 core units of the Ministry. Each cluster was randomly assigned to one of four groups: Control, Exp, Info and ExpInfo. The experiment was divided into five periods (T in {1, . . . , 5}). At T = 2, T = 3, T = 4, the Info units received phishing prevention emails. At T = 1, the Exp units received a fake phishing email and a short debrief. The ExpInfo units received both types of treatment. At T = 5, all groups received a fake phishing email. 

The aim of the experiment was therefore to determine the effectiveness of different prevention campaigns. A secondary analysis was also to understand which age and gender characteristics are most likely to be victims of phishing attacks. This would allow prevention campaigns to be more targeted at those most at risk. 

In their experiment, the researchers did not use any means to check whether the treatments were actually taken or not.  They state that they sent several short emails to participants to encourage them to take the treatment. However, having no concrete information on whether or not the treatment was taken does not allow us to deal with the one-sided and two-sided non-compliance issues. That forms an obvious bias in the results of the experiment. In addition, a whole division of the ministry was unintentionally notified that the first phishing email was fake. Thus, The Control and Info units of division C received this notification as well. This may have affected the results, creating intervention spillover effects within that division. Therefore, we will comment on the results with and without this division, which will also allow us to test the robustness of the treatments. 




## Presentation of data and variables

The file “phishing_dataset.csv” gives the data obtained in the experiment. 

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing <- read.csv("/Users/martinbeaufils/Downloads/phishing_dataset.csv") # data loading
head(data_phishing) 
```



- Column “group” indicates in which treatment a subject was with “1”, “2”, “3” and “4” corresponding to “Control”, “Info”, “Exp” and “ExpInfo”, respectively. 

- Columns “cluster” and “division” indicate at which basic unit and organizational division a subject is working. Indeed, the authors randomized the subjects at the level of the lowest known organizational unit, henceforth referred to as “basic unit”. In total there is 184 unique basic units, with an average of 61 subjects per basic unit. The authors have not opted for randomization at the individual level “to avoid contamination of the results by intervention spillover effects”. 

- Column “age” indicates the age of the subject. 

- Column “gender” indicates that a subject is female if the value is “F” and a male if the value is “M”. 

- Column “int_employee” is a dummy variable indicating whether a subject is an internal employee. 

- Columns “visit”, “fill” and “visit_fill” are response variables to the second phishing email at time T= 5. “visit” indicates whether subjects clicked the link and visited the website, “fill” indicates whether subjects filled in their password, and “visit_fill” indicates whether they filled in their password conditional on having visited the website. 

- Similarly, columns “visit_1”, “fill_1” and “visit_fill_1” are response variables to the first phishing email at time T=1 (only groups Exp and ExpInfo received this email.). 

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
library(tidyverse)  
library(cowplot) # to create tables of charts
library(gtsummary) # to make aesthetic regression tables
library(knitr) # to create tables
library(kableExtra) # to make aesthetic tables
```



## Data cleaning

We first clean up the data, recoding the treatment indicators and adding the age categories. We also created a table without the C division, which will be useful for the analysis without this division. Finally, we created two vectors 'Group' and 'Outcome', which will be used for the analysis.

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing <- data_phishing %>%
  # recoding of the treatment variable
  mutate(group = case_when(
    group == 1 ~ "Control",
    group == 2 ~ "Info",
    group == 3 ~ "Exp",
    group == 4 ~ "ExpInfo"
  )) %>%
  # changing the order of group variable, putting control group first
  mutate(group = fct_relevel(group, "Control", "Info", "Exp", "ExpInfo")) %>%
  # recoding of the age variable
  mutate(
    age_categories = case_when(
      age <= 25 ~ "16-25",
      age >= 26 & age <= 35 ~ "26-35",
      age >= 36 & age <= 45 ~ "36-45",
      age >= 46 & age <= 55 ~ "46-55",
      age > 55 ~ ">55"
    )
  ) %>%
  # changing the order of age_categories, from the youngest to the oldest
  mutate(age_categories = fct_relevel(age_categories, "16-25", "26-35", "36-45", "46-55")) %>%
  # recoding of the gender variable : O for Female, 1 for Male
  mutate(gender = case_when(gender == "M" ~ 1,
                            gender == "F" ~ 0)) %>%
  # changing the order of division variable, division with B as reference
  mutate(division = fct_relevel(division, "B", "A", "C", "D", "E")) 

data_phis_c <- data_phishing %>%
  filter(division == 'A' | division == 'B' | division == 'D' | division == 'E') # creation of a data table without division C

# creating two vectors with the outcomes and groups
Outcome = c('Visit', 'Fill', 'Visit_Fill')
Group = c('Control','Info','Exp','ExpInfo')
```

## Treatment balance


To begin with, we compared the characteristics of the different groups. For a randomized analysis, it is necessary that the units of the treatment and control groups are similar so that the treatment effect is not masked by other variables. As explained, there was a problem with division C. Therefore, we propose to compare the characteristics of the different groups, with and without this division.


#### Total number of units per group {.tabset .tabset-pills}

Regarding the number of the units, it is noted in the article : 

"We implemented two interventions: information provision (Info) and experience (Exp).
We used a 2x2 design and subjects were divided into four groups of roughly equal size: Control
(2723 employees), Info (2740), Exp (2724) and ExpInfo (2742)."

##### With division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing %>%
  group_by(group) %>%
  summarise(nb_group = n()) #count of units by group
```

There are no mistakes here. Now let's see without the C division.

##### Without division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c %>%
  group_by(group) %>%
  summarise(nb_group = n())
```

The problem here is that the groups are clearly no longer the same size. For example, there is a difference of about 400 units between the control group and the "Info" treatment group.

#### Number of female and male units {.tabset .tabset-pills}

Here we simply look at the gender distribution in the ministry, to check that there are no errors in the article. It is noted : 

"Most subjects were males (60,6%), [...]."

First, we calculate the total number of men (1) and women (0), with and without division C.

##### With division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing %>%
  group_by(gender) %>%
  summarise(nb_obs = n()) #count of units by gender
```

##### Without division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c %>%
  group_by(gender) %>%
  summarise(nb_obs = n())
```

##### Comparison

Then, we calculate the distribution.

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

rep_sex = mean(data_phishing$gender, na.rm = TRUE)*100 # gender distribution among the units
rep_sex_c = mean(data_phis_c$gender, na.rm = TRUE)*100

#creating a summary table
kbl((data.frame(Object = c('Gender mean'), With_division_C = c(rep_sex), Without_division_C = c(rep_sex_c)))) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

The figures are therefore consistent with the researchers' claims, and removing division C does not cause a large bias.


#### Age of the units {.tabset .tabset-pills}

Here we look at the age distribution among the units. According to the paper: "[...] an average age of 47 years."

##### Overall average

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
mean_age = mean(data_phishing$age, na.rm = TRUE) # age distribution among the units
mean_age_c = mean(data_phis_c$age, na.rm = TRUE)

# creating a summmary table
kbl((data.frame(Object = c('Age mean'), With_division_C = c(mean_age), Without_division_C = c(mean_age_c)))) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

The numbers are consistent. We then look at the age distribution, according to the treatment. We first check with division C, then without. We use charts to make it more readable.

##### With division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phishing) + # box plot showing the age distribution according to the treatment
  geom_boxplot(aes(x = group, y = age , color = group)) +
  xlab('Group') +
  labs(title = 'Age boxplot') +
  theme(plot.title = element_text(hjust = 0.5)) #putting the title in the middle
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phishing) + # plot showing the age distribution according to the treatment
  geom_density(aes(x = age, color = group)) +
  labs(title = 'Age distribution') +
  theme(plot.title = element_text(hjust = 0.5))
```

Here, the groups seem similar. Let's see without division C.

##### Without division C


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phis_c) +
  geom_boxplot(aes(x = group, y = age , color = group)) +  
  xlab('Group') +
  labs(title = 'Age boxplot without division C') +
  theme(plot.title = element_text(hjust = 0.5))
```

Visually, the average age per group seems to differ.

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
ggplot(data = data_phis_c) +
  geom_density(aes(x = age, color = group)) +
  labs(title = 'Age distribution without division C') +
  theme(plot.title = element_text(hjust = 0.5))
```


#### Summary table of the characteristics of the units depending on the treatment {.tabset .tabset-pills}

##### With division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phishing %>%
  group_by(group) %>% # data are grouped by treatment
  summarise(nb_obs = n(), mean_age = mean(age, na.rm = TRUE), sex_repartition = mean(gender, na.rm = TRUE)*100, mean_int_employee = mean(int_employee, na.rm = TRUE)*100,) # mean of the different characteristics of the units
```

##### Without division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c %>%
  group_by(group) %>%
  summarise(nb_obs = n(), mean_age = mean(age, na.rm = TRUE), sex_repartition = mean(gender, na.rm = TRUE)*100, mean_int_employee = mean(int_employee, na.rm = TRUE)*100,)
```


Before the removal of division C due to an error on the part of the researchers, the different treatment groups had roughly the same characteristics. The removal of this division caused slight shifts in the distribution of the control variables in the treatment groups. These groups are no longer completely identical or of the same size. For example, the control group has 400 more units and 4 percentage points more women than the Info group. 

## Randomization inference {.tabset .tabset-pills}


We decided to focus our randomization inference by removing the C division from the analysis. Indeed, given the difficulties encountered by the researchers with this unit, it seemed to us biased to take it into account.

We have divided this analysis by looking at each treatment individually. In this way, we can first determine which of the treatments obviously reduce the likelihood of falling victim to a phishing attack.

### Exp

#### Calculation of ATEs 


```{r, eval = TRUE, message = FALSE, warning =  FALSE}

observed_difference_v = mean(data_phis_c$visit[data_phis_c$group == 'Exp']) - mean(data_phis_c$visit[data_phis_c$group == 'Control']) # difference of the averages for the visit outcome of the Exp group
observed_difference_f = mean(data_phis_c$fill[data_phis_c$group == 'Exp']) - mean(data_phis_c$fill[data_phis_c$group == 'Control']) # fill outcome
observed_difference_vf = mean(data_phis_c$visit_fill[data_phis_c$group == 'Exp'], na.rm = TRUE) - mean(data_phis_c$visit_fill[data_phis_c$group == 'Control'], na.rm = TRUE) # visit_fill outcome

# displaying differences
kbl(data.frame(Outcome, ATE = c(observed_difference_v,observed_difference_f, observed_difference_vf)))%>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

The observed differences seem to establish a negative correlation between the 'Exp' treatment and the control group: this treatment reduced the different outcomes by 11 to 13 percentage points. For instance, the number of units which visited the website has been reduced by 13 percentage points, compared to the control group. We now need to know whether these differences withstand the sharp null hypothesis.

#### Calculation of the proportions of treated units

Here we calculate the proportions of treated units for each treatment compared to the numbers of control units. These proportions are necessary for randomization inference in a cluster experiment like ours.

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c_exp <- data_phis_c %>%
  filter(group == 'Control' | group == 'Exp') %>%
  mutate(ind_group = ifelse(group == 'Exp',1,0)) # creation of an indicator worth 1 if the unit is treated and 0 otherwise
                              

prop_exp = sum(data_phis_c_exp$ind_group)/nrow(data_phis_c_exp) # proportion of units receiving the Exp treatment
```

#### Randomization inference loop

As explained, our experiment is based on cluster allocation. Thus, it is necessary to randomize on the clusters and not on the units themselves. As each cluster consists of one and the same treatment, we randomized according to the proportion of treated. 

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# creating three vectors that will store the randomized differences
diff_simulations <- rep(NA, 1000) # visit outcome 
diff_simulations_f_exp <- rep(NA, 1000) # fill outcome 
diff_simulations_vf_exp <- rep(NA, 1000) # visit_fill outcome 


#loop for simulations
for (i in 1:1000){

data_phis_c_exp <- data_phis_c_exp %>%
#We construct a new group variable (with mutate function) which randomly mixes the elements of the group variable taking into account the proportion of treated units (with a binomial distribution (rbinom))
  group_by(cluster) %>%
  mutate(new_group = rbinom(1, 1, prop_exp)) %>%
  mutate(new_group = case_when(new_group == 1 ~ 'Exp',
                               new_group == 0 ~ 'Control'))

#We calculate the differences for each of the 1000 distributions that we place at the i-th coordinate

diff_simulations[i] <- mean(data_phis_c_exp$visit[data_phis_c_exp$new_group == "Exp"]) - mean(data_phis_c_exp$visit[data_phis_c_exp$new_group=="Control"]) # visit outcome 

diff_simulations_f_exp[i] <- mean(data_phis_c_exp$fill[data_phis_c_exp$new_group == "Exp"]) - mean(data_phis_c_exp$fill[data_phis_c_exp$new_group=="Control"]) # fill outcome

diff_simulations_vf_exp[i] <- mean(data_phis_c_exp$visit_fill[data_phis_c_exp$new_group == "Exp"], na.rm = TRUE) - mean(data_phis_c_exp$visit_fill[data_phis_c_exp$new_group=="Control"], na.rm = TRUE) # visit_fill outcome
}

```

#### Charts

```{r, eval = TRUE}

#Chart of visit outcome
data_simulations <- tibble(diff_simulations=diff_simulations)
graph_exp <- ggplot(data_simulations, aes(x = diff_simulations)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  #The average of the random differences in black
  geom_vline(xintercept = mean(data_simulations$diff_simulations), color = 'black') +
  #The actual average observed in coral
  geom_vline(xintercept = observed_difference_v, color = 'coral') +
  xlab("Visit") +
  theme_minimal()

#Fill outcome
data_simulations_f_exp <- tibble(diff_simulations_f_exp=diff_simulations_f_exp)
graph_fill_exp <- ggplot(data_simulations_f_exp, aes(x = diff_simulations_f_exp)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_f_exp$diff_simulations_f_exp), color = 'black') +
  geom_vline(xintercept = observed_difference_f, color = 'coral') +
  xlab("Fill") +
  theme_minimal()

#Visit_fill outcome
data_simulations_vf_exp <- tibble(diff_simulations_vf_exp=diff_simulations_vf_exp)
graph_visitfill_exp <- ggplot(data_simulations_vf_exp, aes(x = diff_simulations_vf_exp)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_vf_exp$diff_simulations_vf_exp), color = 'black') +
  geom_vline(xintercept = observed_difference_vf, color = 'coral') +
  xlab("Visit_Fill") +
  theme_minimal()

#Displaying the exp charts with plot_grid function (cowplot package)
print(plot_grid(graph_exp,graph_fill_exp,graph_visitfill_exp))
```

Visually, the negative effect of the treatment seems to be confirmed.

#### P-values

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Calculation of the one-sided (op) and the two-sided p-value (tp)

# Visit outcome
opve = (sum(data_simulations$diff_simulations <= observed_difference_v)/1000)*100
tpve = (sum(abs(data_simulations$diff_simulations) >=  abs(observed_difference_v))/1000)*100

# Fill outcome
opfe = (sum(data_simulations_f_exp$diff_simulations_f_exp <= observed_difference_f)/1000)*100 
tpfe = (sum(abs(data_simulations_f_exp$diff_simulations_f_exp) >=  abs(observed_difference_f))/1000)*100

# Visit_Fill outcome
opvfe = (sum(data_simulations_vf_exp$diff_simulations_vf_exp <= observed_difference_vf)/1000)*100 
tpvfe = (sum(abs(data_simulations_vf_exp$diff_simulations_vf_exp) >=  abs(observed_difference_vf))/1000)*100

# Displaying p-values in a table
kbl(data.frame(Outcome, one_sided_p_values = c(opve, opfe, opvfe), two_sided_p_values = c(tpve ,tpfe ,tpvfe))) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

As the p-values are relatively low, it seems consistent to reject the sharp null hypothesis for this treatment.

### Info

#### Calculation of ATEs

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# difference of the averages for each treatment (for the Info group)
observed_difference_v_info = mean(data_phis_c$visit[data_phis_c$group == 'Info']) - mean(data_phis_c$visit[data_phis_c$group == 'Control']) # visit outcome

observed_difference_f_info = mean(data_phis_c$fill[data_phis_c$group == 'Info']) - mean(data_phis_c$fill[data_phis_c$group == 'Control']) #fill outcome

observed_difference_vf_info = mean(data_phis_c$visit_fill[data_phis_c$group == 'Info'], na.rm = TRUE) - mean(data_phis_c$visit_fill[data_phis_c$group == 'Control'], na.rm = TRUE) #visit_fill outcome

# displaying differences  
kbl((data.frame(Outcome, ATE = c(observed_difference_v_info,observed_difference_f_info, observed_difference_vf_info)))) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

The observed differences seem to establish a negative correlation between the 'Info' treatment and the control group: this treatment reduced the different outcomes by 7 to 8 percentage points. For instance, the number of units which visited the website has been reduced by 8 percentage points, compared to the control group.

#### Calculation of the proportions of treated units

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c_info <- data_phis_c %>%
  filter(group == 'Control' | group == 'Info') %>%
  mutate(ind_group = ifelse(group == 'Info',1,0)) # creation of an indicator worth 1 if the unit is treated and 0 otherwise
                            

prop_info = sum(data_phis_c_info$ind_group)/nrow(data_phis_c_info) # proportion of units receiving the Info treatment
```

#### Randomization inference loop


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
diff_simulations_info <- rep(NA, 1000) # visit outcome
diff_simulations_f_info <- rep(NA, 1000) # fill outcome
diff_simulations_vf_info <- rep(NA, 1000) # visit_fill outcome

for (i in 1:1000){

data_phis_c_info <- data_phis_c_info %>%
  group_by(cluster) %>%
  mutate(new_group = rbinom(1, 1, prop_info)) %>%
  mutate(new_group = case_when(new_group == 1 ~ 'Info',
                               new_group == 0 ~ 'Control'))

diff_simulations_info[i] <- mean(data_phis_c_info$visit[data_phis_c_info$new_group == "Info"]) - mean(data_phis_c_info$visit[data_phis_c_info$new_group=="Control"]) #visit outcome

diff_simulations_f_info[i] <- mean(data_phis_c_info$fill[data_phis_c_info$new_group == "Info"]) - mean(data_phis_c_info$fill[data_phis_c_info$new_group=="Control"]) # fill outcome

diff_simulations_vf_info[i] <- mean(data_phis_c_info$visit_fill[data_phis_c_info$new_group == "Info"], na.rm = TRUE) - mean(data_phis_c_info$visit_fill[data_phis_c_info$new_group=="Control"], na.rm = TRUE) #visit_fill outcome
}

```

#### Charts

```{r, eval = TRUE}

# visit outcome
data_simulations_info <- tibble(diff_simulations_info=diff_simulations_info)
graph_info <- ggplot(data_simulations_info, aes(x = diff_simulations_info)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_info$diff_simulations_info), color = 'black') +
  geom_vline(xintercept = observed_difference_v_info, color = 'coral') +
  xlab("Visit") +
  theme_minimal()

# fill outcome
data_simulations_f_info <- tibble(diff_simulations_f_info=diff_simulations_f_info)
graph_fill_info <- ggplot(data_simulations_f_info, aes(x = diff_simulations_f_info)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_f_info$diff_simulations_f_info), color = 'black') +
  geom_vline(xintercept = observed_difference_f_info, color = 'coral') +
  xlab("Fill") +
  theme_minimal()

# visit_fill outcome
data_simulations_vf_info <- tibble(diff_simulations_vf_info=diff_simulations_vf_info)
graph_visitfill_info <- ggplot(data_simulations_vf_info, aes(x = diff_simulations_vf_info)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_vf_info$diff_simulations_vf_info), color = 'black') +
  geom_vline(xintercept = observed_difference_vf_info, color = 'coral') +
  xlab("Visit_Fill") +
  theme_minimal()

# Displaying the charts
plot_grid(graph_info,graph_fill_info,graph_visitfill_info)
```

Visually, it is less clear here that we can reject the sharp null hypothesis: the treatment effect does not seem marginal enough to reject with certainty.

#### P-values


```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Calculation of the one-sided and the two-sided p-value

# outcome Visit
opvi = (sum(data_simulations_info$diff_simulations_info <= observed_difference_v_info)/1000)*100 
tpvi = (sum(abs(data_simulations_info$diff_simulations_info) >=  abs(observed_difference_v_info))/1000)*100

# outcome Visit
opfi = (sum(data_simulations_f_info$diff_simulations_f_info <= observed_difference_f_info)/1000)*100 # 
tpfi = (sum(abs(data_simulations_f_info$diff_simulations_f_info) >=  abs(observed_difference_f_info))/1000)*100

# outcome Visit
opvfi = (sum(data_simulations_vf_info$diff_simulations_vf_info <= observed_difference_vf_info)/1000)*100 # 
tpvfi = (sum(abs(data_simulations_vf_info$diff_simulations_vf_info) >=  abs(observed_difference_vf_info))/1000)*100

kbl(data.frame(Outcome, one_sided_p_values = c(opvi, opfi, opvfi), two_sided_p_values = c(tpvi ,tpfi ,tpvfi))) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

As we see from the graph and table above, it is more difficult here to reject the sharp null hypothesis for this treatment and particularly for the 'Visit' outcome. Indeed, about 10% of the values are more extreme than that observed for this outcome. Nevertheless, the general trend seems to be in the direction of the effectiveness of the treatment.

### ExpInfo

#### Calculation of ATEs

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# difference of the averages for each treatment (for the ExpInfo group)

observed_difference_v_expinfo = mean(data_phis_c$visit[data_phis_c$group == 'ExpInfo']) - mean(data_phis_c$visit[data_phis_c$group == 'Control']) # visit outcome

observed_difference_f_expinfo = mean(data_phis_c$fill[data_phis_c$group == 'ExpInfo']) - mean(data_phis_c$fill[data_phis_c$group == 'Control']) # fill outcome

observed_difference_vf_expinfo = mean(data_phis_c$visit_fill[data_phis_c$group == 'ExpInfo'], na.rm = TRUE) - mean(data_phis_c$visit_fill[data_phis_c$group == 'Control'], na.rm = TRUE) #visit_fill outcome

# displaying differences
kbl((data.frame(Outcome, ATE = c(observed_difference_v_expinfo,observed_difference_f_expinfo, observed_difference_vf_expinfo)))) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

The observed differences seem to establish a negative correlation between the 'ExpInfo' treatment and the control group: this treatment reduced the different outcomes by 9 to 15 percentage points. For instance, the number of units which visited the website has been reduced by 10 percentage points, compared to the control group.  Let's see if this difference stands up to randomization inference.

#### Calculation of the proportions of treated units

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_phis_c_expinfo <- data_phis_c %>%
  filter(group == 'Control' | group == 'ExpInfo') %>%
  mutate(ind_group = ifelse(group == 'ExpInfo',1,0)) # creation of an indicator worth 1 if the unit is treated and 0 otherwise
                            

prop_expinfo = sum(data_phis_c_expinfo$ind_group)/nrow(data_phis_c_expinfo) # proportion of units receiving the ExpInfo treatment
```

#### Randomization inference loop

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
diff_simulations_expinfo <- rep(NA, 1000) #visit outcome
diff_simulations_f_expinfo <- rep(NA, 1000) #fill outcome
diff_simulations_vf_expinfo <- rep(NA, 1000) #visit_fill outcome

for (i in 1:1000){

data_phis_c_expinfo <- data_phis_c_expinfo %>%
  group_by(cluster) %>%
  mutate(new_group = rbinom(1,1,prop_expinfo)) %>%
  mutate(new_group = case_when(new_group == 1 ~ 'ExpInfo',
                               new_group == 0 ~ 'Control'))

diff_simulations_expinfo[i] <- mean(data_phis_c_expinfo$visit[data_phis_c_expinfo$new_group == "ExpInfo"]) - mean(data_phis_c_expinfo$visit[data_phis_c_expinfo$new_group=="Control"]) #visit outcome

diff_simulations_f_expinfo[i] <- mean(data_phis_c_expinfo$fill[data_phis_c_expinfo$new_group == "ExpInfo"]) - mean(data_phis_c_expinfo$fill[data_phis_c_expinfo$new_group=="Control"]) #fill outcome

diff_simulations_vf_expinfo[i] <- mean(data_phis_c_expinfo$visit_fill[data_phis_c_expinfo$new_group == "ExpInfo"], na.rm = TRUE) - mean(data_phis_c_expinfo$visit_fill[data_phis_c_expinfo$new_group=="Control"], na.rm = TRUE) #visit_fill outcome
}
```

#### Charts

```{r, eval = TRUE}

#visit outcome
data_simulations_expinfo <- tibble(diff_simulations_expinfo=diff_simulations_expinfo)
graph_expinfo <- ggplot(data_simulations_expinfo, aes(x = diff_simulations_expinfo)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_expinfo$diff_simulations_expinfo), color = 'black') +
  geom_vline(xintercept = observed_difference_v_expinfo, color = 'coral') +
  xlab("Visit") + 
  theme_minimal()

# fill outcome
data_simulations_f_expinfo <- tibble(diff_simulations_f_expinfo=diff_simulations_f_expinfo)
graph_fill_expinfo <- ggplot(data_simulations_f_expinfo, aes(x = diff_simulations_f_expinfo)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_f_expinfo$diff_simulations_f_expinfo), color = 'black') +
  geom_vline(xintercept = observed_difference_f_expinfo, color = 'coral') +
  xlab("Fill") +
  theme_minimal()

# visit_fill outcome
data_simulations_vf_expinfo <- tibble(diff_simulations_vf_expinfo=diff_simulations_vf_expinfo)
graph_visitfill_expinfo <- ggplot(data_simulations_vf_expinfo, aes(x = diff_simulations_vf_expinfo)) +
  geom_density(color = 'black', fill = 'deepskyblue3', alpha = 0.5) +
  geom_vline(xintercept = mean(data_simulations_vf_expinfo$diff_simulations_vf_expinfo), color = 'black') +
  geom_vline(xintercept = observed_difference_vf_expinfo, color = 'coral') +
  xlab("Visit_Fill") +
  theme_minimal()

# displaying the charts
plot_grid(graph_expinfo,graph_fill_expinfo,graph_visitfill_expinfo)
```

#### P-values

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
#Calculation of the one-sided and the two-sided p-value

# outcome Visit
opvei = (sum(data_simulations_expinfo$diff_simulations_expinfo <= observed_difference_v_expinfo)/1000)*100 
tpvei = (sum(abs(data_simulations_expinfo$diff_simulations_expinfo) >=  abs(observed_difference_v_expinfo))/1000)*100

# outcome Fill
opfei = (sum(data_simulations_f_expinfo$diff_simulations_f_expinfo <= observed_difference_f_expinfo)/1000)*100 
tpfei = (sum(abs(data_simulations_f_expinfo$diff_simulations_f_expinfo) >=  abs(observed_difference_f_expinfo))/1000)*100

# outcome VisitFill
opvfei = (sum(data_simulations_vf_expinfo$diff_simulations_vf_expinfo <= observed_difference_vf_expinfo)/1000)*100 
tpvfei = (sum(abs(data_simulations_vf_expinfo$diff_simulations_vf_expinfo) >=  abs(observed_difference_vf_expinfo))/1000)*100

kbl(data.frame(Outcome, one_sided_p_values = c(opvei, opfei, opvfei), two_sided_p_values = c(tpvei ,tpfei, tpvfei))) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

As the p-values are relatively low, it seems consistent to reject the sharp null hypothesis for this treatment.

### Global Chart

```{r, echo = TRUE, message = FALSE, warning = FALSE, fig.width = 10, fig.height = 5, fig.fullwidth=TRUE}
first_row <- plot_grid(graph_exp, graph_fill_exp, graph_visitfill_exp, labels = 'Exp', ncol = 3)
second_row <- plot_grid(graph_info, graph_fill_info, graph_visitfill_info, labels = 'Info', ncol = 3)
third_row <- plot_grid(graph_expinfo, graph_fill_expinfo, graph_visitfill_expinfo, labels = 'ExpInfo', ncol = 3)

plot_grid(first_row, second_row, third_row,  nrow = 3) # displaying final results
```


## Weighted t-test {.tabset .tabset-pills}

The weighted t-test correspond to the researchers' first analysis and we propose to reproduce it here.We study for each treatment the share of units that visited and filled in the form and compare the differences.

### With division C

We first create tables that will be useful for this analysis and calculate the proportions of units treated for each treatment.

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
#creation of tables containing the proportions of outcomes per cluster
data_wtt <- data_phishing %>%
  group_by(group, cluster) %>%
  summarise(prop_cluster = n()/10929, prop_fill = sum(fill)/n(), prop_visit = sum(visit)/n(),  prop_visit_fill = sum(visit_fill, na.rm = TRUE)/sum(visit))
```

Then for each group, we calculate the weighted averages of each outcome.

#### Control Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

fc = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'Control'], w = data_wtt$prop_cluster[data_wtt$group == 'Control']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the Control group

vc = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'Control'], w = data_wtt$prop_cluster[data_wtt$group == 'Control']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the Control group

vfc = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'Control'], w = data_wtt$prop_cluster[data_wtt$group == 'Control'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the Control group
```

#### Exp Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

ve = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'Exp'], w = data_wtt$prop_cluster[data_wtt$group == 'Exp']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the Exp group

fe = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'Exp'], w = data_wtt$prop_cluster[data_wtt$group == 'Exp']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the Exp group

vfe = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'Exp'], w = data_wtt$prop_cluster[data_wtt$group == 'Exp'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the Exp group
```

#### Info Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

vi = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'Info'], w = data_wtt$prop_cluster[data_wtt$group == 'Info']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the Info group

fi = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'Info'], w = data_wtt$prop_cluster[data_wtt$group == 'Info']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the Info group

vfi = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'Info'], w = data_wtt$prop_cluster[data_wtt$group == 'Info'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the Info group
```

#### ExpInfo Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

vei = weighted.mean(x = data_wtt$prop_visit[data_wtt$group == 'ExpInfo'], w = data_wtt$prop_cluster[data_wtt$group == 'ExpInfo']) # calculation of the weighted average by the proportion of clusters of the average outcome (Visit) for the ExpInfo group

fei = weighted.mean(x = data_wtt$prop_fill[data_wtt$group == 'ExpInfo'], w = data_wtt$prop_cluster[data_wtt$group == 'ExpInfo']) # calculation of the weighted average by the proportion of clusters of the average outcome (Fill) for the ExpInfo group

vfei = weighted.mean(x = data_wtt$prop_visit_fill[data_wtt$group == 'ExpInfo'], w = data_wtt$prop_cluster[data_wtt$group == 'ExpInfo'], na.rm = TRUE) # calculation of the weighted average by the proportion of clusters of the average outcome (VisitFill) for the ExpInfo group
```

#### Global Chart

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
# creation of data tables to allow plotting results

dataggv <- data.frame(group = c('Control',"Info","Exp","ExpInfo"), visit_mean = c(vc,vi,ve,vei)*100) #visit outcome

dataggf <- data.frame(group = c('Control',"Info","Exp","ExpInfo"), fill_mean = c(fc,fi,fe,fei)*100) #fill outcome

dataggvf <- data.frame(group = c('Control',"Info","Exp","ExpInfo"), vf_mean = c(vfc,vfi,vfe,vfei)*100) #visit_fill outcome
```


```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
#creation of the plots (proportion of visit, fill, visit_fill by treatment arm)

#visit
ggv = ggplot(dataggv, aes(x = group, y = visit_mean)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = visit_mean), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,40) +
ggtitle("Proportion of Visits by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()

#fill
ggf = ggplot(dataggf, aes(x = group, y = fill_mean)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = fill_mean), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,40) +
ggtitle("Proportion of Fill by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()

#visit_fill
ggvf = ggplot(dataggvf, aes(x = group, y = vf_mean)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = vf_mean), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,80) +
ggtitle("Proportion of Visit_Fill by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()

plot_grid(ggv, ggf, ggvf) # displaying of the 3 plots together
```

Overall, the figure shows that the control group has the highest proportion of units that visited the phishing site and filled in the form. Of all the units that visited the site, the control group also filled in the form the most (visit_fill outcome). This first weighted average analysis therefore allows us to estimate the beneficial effect of the treatment: the treatment groups have the lowest percentage of visits and form fillings.

On average, it seems that the Exp and ExpInfo treatments are the most effective on each outcome : for instance, these treatments reduce the share of form filling after visiting the site (visit_fill outcome) by about 10 percentage points.

### Without division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}

#creation of tables containing the proportions of outcomes per cluster
data_wtt_c <- data_phis_c %>%
  group_by(group, cluster) %>%
  summarise(prop_cluster = n()/10929, prop_fill = sum(fill)/n(), prop_visit = sum(visit)/n(),  prop_visit_fill = sum(visit_fill, na.rm = TRUE)/sum(visit))

```

#### Control Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Without division C

#weighted mean of visit for the control group
vc_c = weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'Control'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Control'])

#fill for the control group
fc_c = weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'Control'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Control'])

#visit_fill for the control group
vfc_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'Control'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Control'], na.rm = TRUE)

```

#### Exp Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Without division C

#visit
ve_c = weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'Exp'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Exp'])

#fill
fe_c = weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'Exp'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Exp'])

#visit_fill
vfe_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'Exp'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Exp'], na.rm = TRUE)
```

#### Info Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Without division C

#visit
vi_c= weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'Info'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Info'])

#fill
fi_c =weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'Info'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Info'])

#visit_fill
vfi_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'Info'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'Info'], na.rm = TRUE)
  
```

#### ExpInfo Group

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# Without division C

#visit
vei_c = weighted.mean(x = data_wtt_c$prop_visit[data_wtt_c$group == 'ExpInfo'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'ExpInfo'])

#fill
fei_c = weighted.mean(x = data_wtt_c$prop_fill[data_wtt_c$group == 'ExpInfo'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'ExpInfo'])

#visit_fill
vfei_c = weighted.mean(x = data_wtt_c$prop_visit_fill[data_wtt_c$group == 'ExpInfo'], w = data_wtt_c$prop_cluster[data_wtt_c$group == 'ExpInfo'], na.rm = TRUE)

```

#### Global Chart

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
# creation of data tables to allow plotting results

#visit
dataggv <- data.frame(group = c('Control',"Info","Exp","ExpInfo") ,visit_mean_c = c(vc_c,vi_c,ve_c,vei_c)*100) # creation of data tables to allow plotting results

#fill
dataggf <- data.frame(group = c('Control',"Info","Exp","ExpInfo") ,fill_mean_c = c(fc_c,fi_c,fe_c,fei_c)*100)

#visit_fill
dataggvf <- data.frame(group = c('Control',"Info","Exp","ExpInfo") ,vf_mean_c = c(vfc_c,vfi_c,vfe_c,vfei_c)*100)
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 

#visit 
ggv = ggplot(dataggv, aes(x = group, y = visit_mean_c)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = visit_mean_c), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,40) +
ggtitle("Proportion of Visits by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()

#fill
ggf = ggplot(dataggf, aes(x = group, y = fill_mean_c)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = fill_mean_c), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,40) +
ggtitle("Proportion of Fill by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()

#visit_fill
ggvf = ggplot(dataggvf, aes(x = group, y = vf_mean_c)) +
geom_segment(aes(x = group, xend = group, y = 0, yend = vf_mean_c), colour = "gray60") +
geom_point(size = 4, colour = "deepskyblue3") +
ylim(0,80) +
ggtitle("Proportion of Visit_Fill by Treatment Arm") +
xlab("Treatment Arm") + ylab("Proportion (%)") +
theme_minimal()


plot_grid(ggv, ggf, ggvf) # displaying of the 3 plots together

```

Here we find approximately the same results with the same trend: the effects of all treatments seem beneficial and the Exp and Expinfo treatments seem to show the best results. 

## Linear regression analysis {.tabset .tabset-pills}

Here we look at the main analysis of the experiment, namely which treatments are most effective. In a second part, we will look at age and gender characteristics that may influence the propensity to fall victim to a phishing attack. We use linear regressions.

To automate the linear regression, we first nest the data by outcome. Then, we create a function to do a regression. The function is applied and finally we unnest the data table in order to display the results. After that, we can plot the results with the 95% confident intervals.

### With division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# nesting data by outcome
data_regression <- data_phishing %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression #displaying the data frame
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# we do a regression
function_regression <- function(data){
  data %>%
  lm(value ~ group + gender + as.factor(int_employee) + age_categories + division, data = .) %>%
  broom::tidy(., conf.int = TRUE) %>%
  filter(term %in% c("groupExp", "groupExpInfo", "groupInfo")) %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(-term), ~ round(.*100, 1))
}
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# application of the function
data_regression <- data_regression %>%
  mutate(regression_output = map(data, ~ function_regression(.)))

data_regression
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# unnesting the result
data_regression <- data_regression %>%
  select(-data) %>%
  unnest(regression_output)

# displaying of the table
data_regression
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
# make the graph
data_regression %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```

* Visit outcome:

It can be seen here that the most effective treatment is the Exp one with a reduction of 8.1 percentage points compared to the control group. It is more effective than the ExpInfo treatment by 0.2 percentage points and the Info treatment by 2 percentage points.

* Fill outcome: 

For this outcome the most effective treatment is the ExpInfo one. It allows a reduction of 8.7 percentage points compared to the control group. It is more effective than Exp treatment by 2 percentage points and Info treatment by 3.2 percentage points.

* Visit_Fill outcome:

The order of efficiency for this outcome is the same than for the Fill outcome. Nevertheless, the differences of points of percentage with the control group are much higher for the Exp (reduction of 10.3 percentage points compared to the control group) and ExpInfo treatment (reduction of 14.8 percentage points compared to the control group). On the contrary, for the Info treatment, the difference is smaller for this outcome (reduction of 5 percentage points compared to the control group). However, despite these larger differences (for the Exp and ExpInfo treatment), the confidence intervals are also larger. The precision of the effect of these treatments on this outcome is therefore less precise.

Thus, considering the analysis of these results, one could conclude that the most effective treatment is the ExpInfo one. Indeed, it is the one that allows the most to reduce the number of employees sharing their personal information. Conversely, the treatment that appears to be the least effective is the info one, even though its effect remains positive and not negligible.
All treatments have a positive effect on the treated units. Our analysis allows to find the same conclusions as in the article. 

### Without division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# nesting data by outcome
data_regression_c <- data_phis_c %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression_c #displaying the data frame
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# application of the function
data_regression_c <- data_regression_c %>%
  mutate(regression_output = map(data, ~ function_regression(.)))

data_regression_c
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
# unnesting the result
data_regression_c <- data_regression_c %>%
  select(-data) %>%
  unnest(regression_output)

# displaying of the table
data_regression_c
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
# make the graph
data_regression_c %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```

The results of the analysis without the division C remain essentially the same as announced in the original paper. There is just a difference for the outcome visit where the Exp treatment appears to be more effective than the ExpInfo one.
Nevertheless, we observe that the differences in percentage points are all greater in this analysis. Indeed, with this analysis all the treatment allow an additional reduction of almost 3 percentage points (on average) compared to the control group (compared to the analysis with division C). One way to explain this is that the control group in Division C was accidentally made aware of the experiment. It can therefore be assumed that these units were then more attentive to phishing emails, which would justify these larger effects.

## Robustness of the results {.tabset .tabset-pills}

We now test the robustness of the results, for which we reproduce the same regressions as before but without the control variables.

### With division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2 <- data_phishing %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression2
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
function_regression2 <- function(data){
  data %>%
  lm(value ~ group, data = .) %>%
  broom::tidy(., conf.int = TRUE) %>%
  filter(term %in% c("groupExp", "groupExpInfo", "groupInfo")) %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(-term), ~ round(.*100, 1))
}
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2 <- data_regression2 %>%
  mutate(regression_output = map(data, ~ function_regression2(.)))

data_regression2
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2 <- data_regression2 %>%
  select(-data) %>%
  unnest(regression_output)

data_regression2
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
data_regression2 %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```

When comparing the linear regression analysis containing the division C with and without the control variables, the effects of the different treatments remain broadly the same. The differences between the two analyses for a treatment never exceed one percentage point. The results of this analysis can therefore be considered robust (as announced in the original paper).

### Without division C

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2_c <- data_phis_c %>%
  pivot_longer(cols = c(visit, fill, visit_fill), names_to = "outcome", values_to = "value") %>%
  group_by(outcome) %>%
  nest()

data_regression2_c
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2_c <- data_regression2_c %>%
  mutate(regression_output = map(data, ~ function_regression2(.)))

data_regression2_c
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
data_regression2_c <- data_regression2_c %>%
  select(-data) %>%
  unnest(regression_output)

data_regression2_c
```

```{r, eval = TRUE, message = FALSE, warning =  FALSE, fig.width=8, fig.height=5} 
data_regression2_c %>%
  mutate(term = fct_relevel(term, "groupInfo", "groupExp", "groupExpInfo")) %>%
  mutate(outcome = case_when(outcome == "visit" ~ "Visit", outcome == "fill" ~ "Fill", outcome == "visit_fill" ~ "Visit fill")) %>%
  ggplot(.,
         aes(
           x = term,
           y = estimate,
           ymin = conf.low,
           ymax = conf.high
         )) +
  geom_hline(
    yintercept = 0,
    color = "orange",
    lwd = 0.3
  ) +
  geom_pointrange(
    size = 0.8,
    fatten = 2,
    colour = "deepskyblue3"
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  coord_flip() +
  facet_wrap(~ outcome) +
  ylab("Average Marginal Effects") + xlab("") +
  theme_minimal()
```

For the analysis without the division C, as before, the same results are found except for the Visit Fill outcome of the Info group where the effect drops from -10.4 percentage points compared to the control group to -7.9 percentage points. The results as a whole can therefore be considered quite robust. 

## Heterogeneity of the results {.tabset .tabset-pills}

### With division C

We are now trying to understand which category is more likely to fall victim to a phishing attack. To do this, we run linear regressions, taking women and the age group 16-25 as the reference gender and age group. 

We first recode the variable 'gender' to have clearer tables

```{r, eval = TRUE, message = FALSE}

data_phishing <- data_phishing %>%
  mutate(gender = case_when(gender == 1 ~ "M",
                            gender == 0 ~ "F"))
```

We then create the corresponding regression table.

```{r, eval = TRUE, message = FALSE, warning =  FALSE}
lm_object <- lm(visit ~ group + gender + as.factor(int_employee) + age_categories + division, data = data_phishing) 
lm_gtobjectv <- tbl_regression(lm_object, include = c(gender, age_categories)) %>%
  bold_labels()

lm_object <- lm(fill ~ group + gender + as.factor(int_employee) + age_categories + division, data = data_phishing) 
lm_gtobjectf <- tbl_regression(lm_object, include = c(gender, age_categories)) %>%
  bold_labels()

lm_object <- lm(visit_fill ~ group + gender + as.factor(int_employee) + age_categories + division, data = data_phishing) 
lm_gtobjectvf <- tbl_regression(lm_object, include = c(gender, age_categories)) %>%
  bold_labels()

a <- tbl_merge(tbls = list(lm_gtobjectv, lm_gtobjectf, lm_gtobjectvf), tab_spanner = c("**Visit**", "**Fill**", "**Visit Fill**"))
a
```

It can be seen that the older people are, the more likely they are to be duped by phishing emails. This observation is made in the original paper and is relatively predictable taking into account the familiarity of different generations with hacking risks and new technologies.
Concerning the sex of the units, it seems that men are slightly more likely to be duped than women except for the VisitFill outcome.

### Without division C

We first recode the variable 'gender' to have clearer tables.

```{r, eval = TRUE, message = FALSE}

data_phis_c <- data_phis_c %>%
  mutate(gender = case_when(gender == 1 ~ "M",
                            gender == 0 ~ "F"))
```

We then create the corresponding regression table.

```{r, eval = TRUE, message = FALSE}
lm_object <- lm(visit ~ group + gender + as.factor(int_employee) + age_categories + division, data = data_phis_c) 
lm_gtobject_v <- tbl_regression(lm_object, include = c(gender, age_categories)) %>%
  bold_labels()

lm_object <- lm(fill ~ group + gender + as.factor(int_employee) + age_categories + division, data = data_phis_c) 
lm_gtobject_f <- tbl_regression(lm_object, include = c(gender, age_categories)) %>%
  bold_labels()


lm_object <- lm(visit_fill ~ group + gender + as.factor(int_employee) + age_categories + division, data = data_phis_c) 
lm_gtobject_vf<- tbl_regression(lm_object, include = c(gender, age_categories)) %>%
  bold_labels()



t <- tbl_merge(tbls = list(lm_gtobject_v, lm_gtobject_f, lm_gtobject_vf), tab_spanner = c("**Visit**", "**Fill**", "**Visit Fill**"))
t

```

Without the division C, the results are broadly the same as when the analysis is done with the division C, except for the Visit Fill outcome where individuals aged 26 to 55 are less likely to be duped than younger individuals (age range 16 to 25). Above 55 years of age, individuals are more likely to be duped than younger people. The results therefore seem to contradict each other. We therefore find the non-robust result mentioned in the original paper by the authors.
Moreover, concerning the sex of the units this analysis produces the same results for the Visit and VisitFill. For the Fill outcome, it seems that both sex have the same probability to be duped. The difference compared to the previous analysis is only 1 percentage point (even for the bounds of the confidence interval). It can therefore be neglected.

## Conclusion

In conclusion, our results obtained leads to the same conclusions as the original paper. The three treatments proposed by the researchers to prevent phishing attacks do have a beneficial effect on individuals. The ExpInfo treatment combining experiential and informational learning (which are the other two treatments) is more effective. However, the difference with the other treatments is not significant. The authors therefore deduced that the costs of these treatments raised the question of combining them.
Nevertheless, it is clear that the exclusion of division C is somewhat biased. Indeed, it unbalances the different treatment groups and leads to contradictory results when looking at the link between the age of the individuals and the probability that they give up their personal information.
